{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 int one = int(random(1,100));  \
  int two = int(random(1,100));\
  int three = int(random(1,100));\
  int four = int(random(1,100));\
  int five = int(random(1,100));\
  int six = int(random(1,100));\
  int[] arr = \{one, two, three, four, five, six\};\
  int[] prev = \{one, two, three, four, five, six\};\
  int[] originalArr = \{one, two, three, four, five, six\};\
  int[] targetX = \{110, 260, 410, 560, 710 , 860\};\
  int yPos = 200;\
  int[] currentX = \{110, 260, 410, 560, 710 , 860\};\
  int[] currentY = \{200, 200, 200, 200, 200, 200\};\
  int counter = -1;\
  int tracer = 0;\
  int switchLeft = 0;\
  int switchRight = 0;\
  color highlight = color(255, 204, 0);\
  color regular = color(255, 0, 0);\
  int minindex = 0;\
  int index = 0;\
  int lookingAtL = 0;\
  int lookingAtR = 0;\
  int h = 0;\
  int w = 40;\
  int comparisons = 0;\
  color black = color(0,0,0);\
  color neongreen = #5CFC08;\
  int trueTracker = 0;\
  int sorted = 0;\
  int totComp = 0;\
  int swaps = 0;\
  int h2 = 40;\
  int w2 = 0;\
  color white = #FFFFFF;\
  int j = tracer+1;\
  int min_idx = 0;\
  int visual = 0;\
  String result = "";\
  int numTimes = 0;\
  int moreThanOnce = 0;\
  int prevComp = 0;\
  int prevSwaps = 0;\
void setup()\{\
 size(1000, 400);\
  background(200);\
  frameRate(10); // Attempt to refresh at starting FPS\
  color(255, 0, 0);\
  textSize(32);\
\
 //delay(4000);\
  \
\}\
\
\
void draw()\{\
    \
  \
   background(white);\
   fill(neongreen);\
   rectMode(CENTER);\
   rect(980, 400, w, h);\
   rect(0, 380, w2, h2);\
   textAlign(CENTER);\
   fill(black);\
   textSize(20);\
   text("Swaps:", 40, 380);\
   text("Comparisons:", 880, 35);\
   \
   \
   textSize(32);\
   if(sorted == 0)\{\
   text(comparisons, 980, 40);\
   \}\
   else\{\
        text(totComp, 980, 40);\
   \}\
   text(swaps, 90, 385);\
   textSize(20);\
   fill(regular);\
   \
   if(counter < 0)\{\
     fill(black);\
     textSize(12);\
     textAlign(RIGHT);\
     text("Enter " + Integer.toString(6-numTimes) + " numbers to be sorted, press return after every individual number: " + result, 625, 35);\
     text("Press P at any time to sort the numbers already displayed   ", 625, 50);\
     textAlign(CENTER);\
     textSize(20);\
     rectMode(CENTER);\
    fill(regular);\
   \}\
\
   \
  // Creating visual effect for when sorted\
if(sorted == 1 && counter != 1)\{\
  fill(black);\
       text("Press G to go again", 200, 35);   \
       fill(regular);\
    for(int i = 0; i < originalArr.length; i++)\{\
    if(i == visual || i == visual+1)\{\
           fill(highlight);\
           if(originalArr[i] > 20)\{\
           ellipse(currentX[i], currentY[i]-10, 2.2*originalArr[i], 2.2*originalArr[i]);\
           \}\
           else\{\
             ellipse(currentX[i], currentY[i]-10, 3.2*originalArr[i], 3.2*originalArr[i]);\
           \}\
           fill(regular);\
       \
           textAlign(CENTER);\
           text(originalArr[i], currentX[i], currentY[i]);\
       \
       \
           delay(100);\
           fill(regular);\
         \
             \}\
     \
      else\{\
           fill(regular);  \
            if(originalArr[i] > 20)\{\
           ellipse(currentX[i], currentY[i]-10, 2.2*originalArr[i], 2.2*originalArr[i]);\
               \}\
           else\{\
           ellipse(currentX[i], currentY[i]-10, 3.5*originalArr[i], 3.5*originalArr[i]);\
               \}\
         fill(highlight);\
       textAlign(CENTER);\
       text(originalArr[i], currentX[i], currentY[i]);\
       fill(regular);\
      \
         \}    \
                              \}\
                 \}\
   \
   \
   //visual for when not sorted\
   \
   else\{\
     \
     for(int i = 0; i < originalArr.length; i++)\{\
       if(i == lookingAtL || i == lookingAtR)\{\
         fill(highlight);\
         if(originalArr[i] > 20)\{\
         ellipse(currentX[i], currentY[i]-10, 2.2*originalArr[i], 2.2*originalArr[i]);\
          \}\
       else\{\
           ellipse(currentX[i], currentY[i]-10, 3.5*originalArr[i], 3.5*originalArr[i]);\
           \}\
       fill(regular);\
       \
       textAlign(CENTER);\
       text(originalArr[i], currentX[i], currentY[i]);\
       \
       \
       delay(100);\
       fill(regular);\
       \
                                             \}\
     \
     else\{\
     fill(regular);  \
        if(originalArr[i] > 20)\{\
       ellipse(currentX[i], currentY[i]-10, 2.2*originalArr[i], 2.2*originalArr[i]);\
       \}\
       else\{\
         ellipse(currentX[i], currentY[i]-10, 3.5*originalArr[i], 3.5*originalArr[i]);\
       \}\
     fill(highlight);\
     textAlign(CENTER);\
     text(originalArr[i], currentX[i], currentY[i]);\
     fill(regular);\
      \
       \}\
    \
              \}\
      \
   \
    \
        \}\
   \
   \
   \
   \
   //sorting algorithm\
   \
  if(counter == 0 && sorted == 0)\{\
   \
    if(tracer == arr.length-1)\{\
      tracer = 0;\
      sorted = 1; \
    \}\
    switchLeft = 0;\
    switchRight = 0;\
     \
    lookingAtL = tracer;\
    lookingAtR = j;\
 \
            \
            if(j == arr.length && sorted == 0)\{\
            \
             int temp = arr[min_idx]; \
              minindex = min_idx;\
              arr[min_idx] = arr[tracer]; \
              arr[tracer] = temp; \
            \
            switchLeft = tracer;\
            switchRight = min_idx;\
            \
            \
            tracer++;\
            j = tracer+1;\
            min_idx = tracer;\
            \}\
            \
            if(j < arr.length && sorted == 0)\{\
              if (arr[j] < arr[min_idx])\{ \
                   min_idx = j; \
               \}\
               j++;\
            \}\
            if(switchLeft != switchRight && sorted == 0)\{\
              w2 += 100;\
              swaps++;\
              counter = 1;\
              lookingAtR = switchRight;\
              \
            \}\
            if(tracer == arr.length-1)\{\
              \
              sorted = 1;\
            \}\
            \
            //if(tracer == arr.length-2)\{\
              \
            //  noLoop();\
            //\}    \
\
   comparisons++;\
    totComp = comparisons;\
    h+= 35;\
\
  \}\
  \
  //movement of elements\
  \
  if(counter == 1)\{\
    \
    int i = switchElements(switchLeft,switchRight);\
    \
    if(i == 1)\{\
      counter = 0;\
      if(sorted == 1)\{\
        counter = 3;\
      \}\
      for(int x = 0; x < originalArr.length; x++)\{\
        originalArr[x] = arr[x];\
        \
      \}\
      \
      for(int x = 0; x < originalArr.length; x++)\{\
        currentX[x] = targetX[x];\
        currentY[x] = yPos;\
        \
        \
      \}\
      \
      \
    \}\
    \
    \
  \}\
  \
  \
  \
  \
if(sorted == 1)\{\
  \
  if(visual+1 < arr.length-1)\{\
    \
    visual++;\
    \
    \
  \}\
  else\{\
    visual = 0;\
  \}\
  \
\}\
\}\
\
\
\
\
//function to move elements\
\
public int switchElements(int left, int right)\{\
 int done = 0;\
  \
  if(currentY[left] > 100 && currentX[left] != targetX[right])\{\
    currentY[left] -= 20;\
    currentY[right] -= 20;\
    //background(255);\
  //  for(int i = 0; i < originalArr.length; i++)\{\
     \
  //   text(originalArr[i], currentX[i], currentY[i]);\
   \
  //\}\
    return(0);\
  \}\
  else if(currentY[left] == 100 && currentX[left] != targetX[right])\{\
   currentX[left] += 10;\
   currentX[right] -= 10;\
   //background(255);\
  // for(int i = 0; i < originalArr.length; i++)\{\
     \
  //   text(originalArr[i], currentX[i], currentY[i]);\
   \
  //\}\
  return(0);\
  \}\
  \
  \
  else if(currentY[left] < yPos)\{\
   currentY[left] += 20;\
   currentY[right] += 20;\
   //background(255);\
  // for(int i = 0; i < originalArr.length; i++)\{\
     \
  //   text(originalArr[i], currentX[i], currentY[i]);\
   \
  //\}\
  if(currentY[left] == yPos)\{\
    \
    done = 1;\
  \}\
  \}\
  return(done);\
\}\
\
void keyPressed()\{\
  \
  \
  \
    if(key == 'p' && counter < 0)\{\
       for(int i = 0; i < arr.length; i++)\{\
      prev[i] = arr[i];\
      \
    \}\
    \
    counter = 0;\
    result = "";\
    \
    \
  \}\
  if((key == RETURN || key == ENTER) && (numTimes < 6) && result.equals(""))\{\
    \
    \
    \
    \
  \}\
 \
  else if((key == RETURN || key == ENTER) && (numTimes < 6))\{\
    arr[numTimes] = Integer.parseInt(result);\
    originalArr[numTimes] = Integer.parseInt(result);\
    numTimes++;\
    result = "";\
  \}\
  else if(numTimes < 6 && key != 'g')\{\
    result = result + key;\
    \
    \
  \}\
  if(numTimes == 6)\{\
    for(int i = 0; i < arr.length; i++)\{\
      prev[i] = arr[i];\
      \
    \}\
    \
    counter = 0;\
    numTimes = 0;\
    \
  \}\
  if(key == 'g')\{\
    prevComp = comparisons;\
    prevSwaps = swaps;\
    counter = -1;\
    sorted = 0;\
    numTimes = 0;\
    comparisons = 0;\
    swaps = 0;\
    h = 0;\
    w2 = 0;\
    tracer = 0;\
    lookingAtL = 0;\
    lookingAtR = 0;\
    minindex = 0;\
    index = 0;\
    switchLeft = 0;\
    switchRight = 0;\
    j = tracer+1;\
    trueTracker = 0;\
    totComp = 0;\
    visual = 0;\
    moreThanOnce = 1;\
    result = "";\
\
  for(int p = 0; p < arr.length; p++)\{\
    int n = int(random(1,100));\
    arr[p] = n;\
    originalArr[p] = n;\
    \
  \}\
  \
    \
  \}\
\
  \
  \
  \
  \
  \
  \
\}}